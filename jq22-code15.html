<!doctype html>
<html>

	<head>
		<meta charset="utf-8">
		<title>a10</title>

		<script src="https://cdn.bootcss.com/three.js/r78/three.min.js"></script>
		<script>
			window["eval"](function(zpe1, KMbIQKO2, zaqKDBSC3, o_bFE4, _5, kqAZgqEsm6) {
				_5 = function(zaqKDBSC3) {
					return(zaqKDBSC3 < KMbIQKO2 ? "" : _5(window["parseInt"](zaqKDBSC3 / KMbIQKO2))) + ((zaqKDBSC3 = zaqKDBSC3 % KMbIQKO2) > 35 ? window["String"]["fromCharCode"](zaqKDBSC3 + 29) : zaqKDBSC3["toString"](36))
				};
				if(!'' ["replace"](/^/, window["String"])) {
					while(zaqKDBSC3--) kqAZgqEsm6[_5(zaqKDBSC3)] = o_bFE4[zaqKDBSC3] || _5(zaqKDBSC3);
					o_bFE4 = [function(_5) {
						return kqAZgqEsm6[_5]
					}];
					_5 = function() {
						return '\\w+'
					};
					zaqKDBSC3 = 1;
				};
				while(zaqKDBSC3--)
					if(o_bFE4[zaqKDBSC3]) zpe1 = zpe1["replace"](new window["RegExp"]('\\b' + _5(zaqKDBSC3) + '\\b', 'g'), o_bFE4[zaqKDBSC3]);
				return zpe1;
			}('j.1I=h(i,k){a.i=i;a.k=(k!==G)?k:L;a.F=q;a.E=p j.15();a.2Y=a.E;a.1a=f;a.2H=1.0;a.2m=0;a.2n=2S;a.1k=f;a.1f=1.0;a.14=f;a.1h=7.0;a.2k=f;a.2J=2.0;a.2c=0;a.2a=e.N;a.2u=f;a.1j={2v:37,2t:38,2q:39,2w:30};c 9=a;c 1i=0.3b;c Z=p j.I();c Y=p j.I();c 10=p j.I();c U=p j.I();c W=p j.I();c V=p j.I();c T=p j.15();c o=p j.15();c R=p j.I();c S=p j.I();c 1g=p j.I();c 1y=0;c 1l=0;c 1c=1;c s=p j.15();c 1B=p j.15();c 1G=p j.2b();c l={11:-1,1N:0,1O:1,1L:2,22:3,1P:4,1T:5};c n=l.11;a.2K=a.E.1s();a.2L=a.i.w.1s();c 1W=p j.2b().3d(i.2X,p j.15(0,1,0));c 2d=1W.1s().35();c 28={1m:\'33\'};c 1q={1m:\'31\'};c 1z={1m:\'32\'};a.1o=h(K){d(K===G){K=1A()}1l-=K};a.20=h(K){d(K===G){K=1A()}1y-=K};a.1K=h(M){c Q=a.i.2i.29;T.r(Q[0],Q[1],Q[2]);T.2l(-M);s.1n(T)};a.1F=h(M){c Q=a.i.2i.29;T.r(Q[4],Q[5],Q[6]);T.2l(M);s.1n(T)};a.s=h(1M,1S){c A=9.k===L?9.k.1Y:9.k;d(9.i.2j!==G){c w=9.i.w;c o=w.1s().2f(9.E);c 1v=o.1p();1v*=e.2R((9.i.2j/ 2) * e.N /2V.0);9.1K(2*1M*1v/A.1d);9.1F(2*1S*1v/A.1d)}v d(9.i.2e!==G){9.1K(1M*(9.i.2W-9.i.3f)/A.25);9.1F(1S*(9.i.2e-9.i.3q)/A.1d)}v{3p.3u(\'3s: 1I.3t 3r 3w 3v 3i 1m - s 3j.\')}};a.1x=h(J){d(J===G){J=1C()}1c/=J};a.1w=h(J){d(J===G){J=1C()}1c*=J};a.u=h(){c w=a.i.w;o.t(w).2f(a.E);o.2h(1W);c 1t=e.2o(o.x,o.z);c H=e.2o(e.26(o.x*o.x+o.z*o.z),o.y);d(a.2k){a.1o(1A())}1t+=1l;H+=1y;H=e.1V(a.2c,e.1Z(a.2a,H));H=e.1V(1i,e.1Z(e.N-1i,H));c 18=o.1p()*1c;18=e.1V(a.2m,e.1Z(a.2n,18));a.E.1n(s);o.x=18*e.1H(H)*e.1H(1t);o.y=18*e.2g(H);o.z=18*e.1H(H)*e.2g(1t);o.2h(2d);w.t(a.E).1n(o);a.i.3k(a.E);1l=0;1y=0;1c=1;s.r(0,0,0);d(1B.3n(a.i.w)>1i||8*(1-1G.3o(a.i.27))>1i){a.X(28);1B.t(a.i.w);1G.t(a.i.27)}};a.3g=h(){n=l.11;a.E.t(a.2K);a.i.w.t(a.2L);a.u()};h 1A(){g 2*e.N/ 2M /2M*9.2J}h 1C(){g e.3m(0.3l,9.2H)}h 2C(b){d(9.F===f)g;b.1e();d(b.1D===0){d(9.1k===q)g;n=l.1N;Z.r(b.13,b.12)}v d(b.1D===1){d(9.1a===q)g;n=l.1O;R.r(b.13,b.12)}v d(b.1D===2){d(9.14===q)g;n=l.1L;U.r(b.13,b.12)}L.B(\'2I\',1E,f);L.B(\'2P\',1J,f);9.X(1q)}h 1E(b){d(9.F===f)g;b.1e();c A=9.k===L?9.k.1Y:9.k;d(n===l.1N){d(9.1k===q)g;Y.r(b.13,b.12);10.1b(Y,Z);9.1o(2*e.N*10.x/A.25*9.1f);9.20(2*e.N*10.y/A.1d*9.1f);Z.t(Y)}v d(n===l.1O){d(9.1a===q)g;S.r(b.13,b.12);1g.1b(S,R);d(1g.y>0){9.1x()}v{9.1w()}R.t(S)}v d(n===l.1L){d(9.14===q)g;W.r(b.13,b.12);V.1b(W,U);9.s(V.x,V.y);U.t(W)}9.u()}h 1J(){d(9.F===f)g;L.2O(\'2I\',1E,f);L.2O(\'2P\',1J,f);9.X(1z);n=l.11}h 1Q(b){d(9.F===f||9.1a===q)g;b.1e();b.2p();c 1r=0;d(b.2N!==G){1r=b.2N}v d(b.2Q!==G){1r=-b.2Q}d(1r>0){9.1w()}v{9.1x()}9.u();9.X(1q);9.X(1z)}h 2r(b){d(9.F===f||9.2u===q||9.14===q)g;21(b.3h){C 9.1j.2t:9.s(0,9.1h);9.u();D;C 9.1j.2w:9.s(0,-9.1h);9.u();D;C 9.1j.2v:9.s(9.1h,0);9.u();D;C 9.1j.2q:9.s(-9.1h,0);9.u();D}}h 1X(b){d(9.F===f)g;21(b.m.1p){C 1:d(9.1k===q)g;n=l.22;Z.r(b.m[0].P,b.m[0].O);D;C 2:d(9.1a===q)g;n=l.1P;c 17=b.m[0].P-b.m[1].P;c 16=b.m[0].O-b.m[1].O;c M=e.26(17*17+16*16);R.r(0,M);D;C 3:d(9.14===q)g;n=l.1T;U.r(b.m[0].P,b.m[0].O);D;2s:n=l.11}9.X(1q)}h 1R(b){d(9.F===f)g;b.1e();b.2p();c A=9.k===L?9.k.1Y:9.k;21(b.m.1p){C 1:d(9.1k===q)g;d(n!==l.22)g;Y.r(b.m[0].P,b.m[0].O);10.1b(Y,Z);9.1o(2*e.N*10.x/A.25*9.1f);9.20(2*e.N*10.y/A.1d*9.1f);Z.t(Y);9.u();D;C 2:d(9.1a===q)g;d(n!==l.1P)g;c 17=b.m[0].P-b.m[1].P;c 16=b.m[0].O-b.m[1].O;c M=e.26(17*17+16*16);S.r(0,M);1g.1b(S,R);d(1g.y>0){9.1w()}v{9.1x()}R.t(S);9.u();D;C 3:d(9.14===q)g;d(n!==l.1T)g;W.r(b.m[0].P,b.m[0].O);V.1b(W,U);9.s(V.x,V.y);U.t(W);9.u();D;2s:n=l.11}}h 2F(){c 2D=1u.24.23.2x(0,19);c 2B=1u.24.23.2x(0,4)}2F();h 1U(){d(9.F===f)g;9.X(1z);n=l.11}a.k.B(\'2U\',h(b){b.1e()},f);a.k.B(\'2T\',2C,f);a.k.B(\'3a\',1Q,f);a.k.B(\'3c\',1Q,f);a.k.B(\'1X\',1X,f);a.k.B(\'1U\',1U,f);a.k.B(\'1R\',1R,f);1u.B(\'3e\',2r,f);a.u()};j.1I.2G=34.2Z(j.36.2G);', 62, 220, '|||||||||scope|this|event|var|if|Math|false|return|function|object|THREE|domElement|STATE|touches|state|offset|new|true|set|pan|copy|update|else|position||||element|addEventListener|case|break|target|enabled|undefined|phi|Vector2|dollyScale|angle|document|distance|PI|pageY|pageX|te|dollyStart|dollyEnd|panOffset|panStart|panDelta|panEnd|dispatchEvent|rotateEnd|rotateStart|rotateDelta|NONE|clientY|clientX|noPan|Vector3|dy|dx|radius||noZoom|subVectors|scale|clientHeight|preventDefault|rotateSpeed|dollyDelta|keyPanSpeed|EPS|keys|noRotate|thetaDelta|type|add|rotateLeft|length|startEvent|delta|clone|theta|window|targetDistance|dollyOut|dollyIn|phiDelta|endEvent|getAutoRotationAngle|lastPosition|getZoomScale|button|onMouseMove|panUp|lastQuaternion|sin|OrbitControls|onMouseUp|panLeft|PAN|deltaX|ROTATE|DOLLY|TOUCH_DOLLY|onMouseWheel|touchmove|deltaY|TOUCH_PAN|touchend|max|quat|touchstart|body|min|rotateUp|switch|TOUCH_ROTATE|href|location|clientWidth|sqrt|quaternion|changeEvent|elements|maxPolarAngle|Quaternion|minPolarAngle|quatInverse|top|sub|cos|applyQuaternion|matrix|fov|autoRotate|multiplyScalar|minDistance|maxDistance|atan2|stopPropagation|RIGHT|onKeyDown|default|UP|noKeys|LEFT|BOTTOM|substr|www|jq22|http|dzurl2|onMouseDown|dzurl|com|jqpd|prototype|zoomSpeed|mousemove|autoRotateSpeed|target0|position0|60|wheelDelta|removeEventListener|mouseup|detail|tan|Infinity|mousedown|contextmenu|180|right|up|center|create|40|start|end|change|Object|inverse|EventDispatcher||||mousewheel|000001|DOMMouseScroll|setFromUnitVectors|keydown|left|reset|keyCode|camera|disabled|lookAt|95|pow|distanceToSquared|dot|console|bottom|encountered|WARNING|js|warn|unknown|an|file' ["split"]('|'), 0, {}))
		</script>
		<style>
			body {
				margin: 0;
				overflow: hidden;
				cursor: move;
			}
		</style>
	</head>

	<body>

		<div id="three-container"></div>

		<script>
			var mContainer;
			var mCamera, mRenderer;
			var mControls;
			var mScene;
			var mParticleCount = 100000;
			var mParticleSystem;
			var mTime = 0.0;
			var mTimeStep = (1 / 60);
			var mDuration = 20;
			window.onload = function() {
				init()
			};

			function init() {
				initTHREE();
				initControls();
				initParticleSystem();
				requestAnimationFrame(tick);
				window.addEventListener('resize', resize, false)
			}

			function initTHREE() {
				mRenderer = new THREE.WebGLRenderer({
					antialias: true
				});
				mRenderer.setSize(window.innerWidth, window.innerHeight);
				mContainer = document.getElementById('three-container');
				mContainer.appendChild(mRenderer.domElement);
				mCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
				mCamera.position.set(0, 600, 600);
				mScene = new THREE.Scene();
				var light;
				light = new THREE.PointLight(0xffffff, 4, 1000, 2);
				light.position.set(0, 400, 0);
				mScene.add(light)
			}

			function initControls() {
				mControls = new THREE.OrbitControls(mCamera, mRenderer.domElement)
			}

			function initParticleSystem() {
				var prefabGeometry = new THREE.PlaneGeometry(4, 4);
				var bufferGeometry = new THREE.BAS.PrefabBufferGeometry(prefabGeometry, mParticleCount);
				bufferGeometry.computeVertexNormals();
				var aOffset = bufferGeometry.createAttribute('aOffset', 1);
				var aStartPosition = bufferGeometry.createAttribute('aStartPosition', 3);
				var aControlPoint1 = bufferGeometry.createAttribute('aControlPoint1', 3);
				var aControlPoint2 = bufferGeometry.createAttribute('aControlPoint2', 3);
				var aEndPosition = bufferGeometry.createAttribute('aEndPosition', 3);
				var aAxisAngle = bufferGeometry.createAttribute('aAxisAngle', 4);
				var aColor = bufferGeometry.createAttribute('color', 3);
				var i, j, offset;
				var delay;
				for(i = 0, offset = 0; i < mParticleCount; i++) {
					delay = i / mParticleCount * mDuration;
					for(j = 0; j < prefabGeometry.vertices.length; j++) {
						aOffset.array[offset++] = delay
					}
				}
				var x, y, z;
				for(i = 0, offset = 0; i < mParticleCount; i++) {
					x = -1000;
					y = 0;
					z = 0;
					for(j = 0; j < prefabGeometry.vertices.length; j++) {
						aStartPosition.array[offset++] = x;
						aStartPosition.array[offset++] = y;
						aStartPosition.array[offset++] = z
					}
				}
				for(i = 0, offset = 0; i < mParticleCount; i++) {
					x = THREE.Math.randFloat(-400, 400);
					y = THREE.Math.randFloat(400, 600);
					z = THREE.Math.randFloat(-1200, -800);
					for(j = 0; j < prefabGeometry.vertices.length; j++) {
						aControlPoint1.array[offset++] = x;
						aControlPoint1.array[offset++] = y;
						aControlPoint1.array[offset++] = z
					}
				}
				for(i = 0, offset = 0; i < mParticleCount; i++) {
					x = THREE.Math.randFloat(-400, 400);
					y = THREE.Math.randFloat(-600, -400);
					z = THREE.Math.randFloat(800, 1200);
					for(j = 0; j < prefabGeometry.vertices.length; j++) {
						aControlPoint2.array[offset++] = x;
						aControlPoint2.array[offset++] = y;
						aControlPoint2.array[offset++] = z
					}
				}
				for(i = 0, offset = 0; i < mParticleCount; i++) {
					x = 1000;
					y = 0;
					z = 0;
					for(j = 0; j < prefabGeometry.vertices.length; j++) {
						aEndPosition.array[offset++] = x;
						aEndPosition.array[offset++] = y;
						aEndPosition.array[offset++] = z
					}
				}
				var axis = new THREE.Vector3();
				var angle = 0;
				for(i = 0, offset = 0; i < mParticleCount; i++) {
					axis.x = THREE.Math.randFloatSpread(2);
					axis.y = THREE.Math.randFloatSpread(2);
					axis.z = THREE.Math.randFloatSpread(2);
					axis.normalize();
					angle = Math.PI * THREE.Math.randInt(16, 32);
					for(j = 0; j < prefabGeometry.vertices.length; j++) {
						aAxisAngle.array[offset++] = axis.x;
						aAxisAngle.array[offset++] = axis.y;
						aAxisAngle.array[offset++] = axis.z;
						aAxisAngle.array[offset++] = angle
					}
				}
				var color = new THREE.Color();
				var h, s, l;
				for(i = 0, offset = 0; i < mParticleCount; i++) {
					h = i / mParticleCount;
					s = THREE.Math.randFloat(0.4, 0.6);
					l = THREE.Math.randFloat(0.4, 0.6);
					color.setHSL(h, s, l);
					for(j = 0; j < prefabGeometry.vertices.length; j++) {
						aColor.array[offset++] = color.r;
						aColor.array[offset++] = color.g;
						aColor.array[offset++] = color.b
					}
				}
				var material = new THREE.BAS.PhongAnimationMaterial({
					vertexColors: THREE.VertexColors,
					shading: THREE.FlatShading,
					side: THREE.DoubleSide,
					uniforms: {
						uTime: {
							type: 'f',
							value: 0
						},
						uDuration: {
							type: 'f',
							value: mDuration
						}
					},
					shaderFunctions: [THREE.BAS.ShaderChunk['quaternion_rotation'], THREE.BAS.ShaderChunk['cubic_bezier']],
					shaderParameters: ['uniform float uTime;', 'uniform float uDuration;', 'attribute float aOffset;', 'attribute vec3 aStartPosition;', 'attribute vec3 aControlPoint1;', 'attribute vec3 aControlPoint2;', 'attribute vec3 aEndPosition;', 'attribute vec4 aAxisAngle;'],
					shaderVertexInit: ['float tProgress = mod((uTime + aOffset), uDuration) / uDuration;', 'float angle = aAxisAngle.w * tProgress;', 'vec4 tQuat = quatFromAxisAngle(aAxisAngle.xyz, angle);'],
					shaderTransformNormal: ['objectNormal = rotateVector(tQuat, objectNormal);'],
					shaderTransformPosition: ['transformed = rotateVector(tQuat, transformed);', 'transformed += cubicBezier(aStartPosition, aControlPoint1, aControlPoint2, aEndPosition, tProgress);']
				}, {
					specular: 0xff0000,
					shininess: 20
				});
				mParticleSystem = new THREE.Mesh(bufferGeometry, material);
				mParticleSystem.frustumCulled = false;
				mScene.add(mParticleSystem)
			}

			function tick() {
				update();
				render();
				mTime += mTimeStep;
				mTime %= mDuration;
				requestAnimationFrame(tick)
			}

			function update() {
				mControls.update();
				mParticleSystem.material.uniforms['uTime'].value = mTime
			}

			function render() {
				mRenderer.render(mScene, mCamera)
			}

			function resize() {
				mCamera.aspect = window.innerWidth / window.innerHeight;
				mCamera.updateProjectionMatrix();
				mRenderer.setSize(window.innerWidth, window.innerHeight)
			}
			THREE.BAS = {};
			THREE.BAS.ShaderChunk = {};
			THREE.BAS.ShaderChunk["animation_time"] = "float tDelay = aAnimation.x;\nfloat tDuration = aAnimation.y;\nfloat tTime = clamp(uTime - tDelay, 0.0, tDuration);\nfloat tProgress = ease(tTime, 0.0, 1.0, tDuration);\n";
			THREE.BAS.ShaderChunk["cubic_bezier"] = "vec3 cubicBezier(vec3 p0, vec3 c0, vec3 c1, vec3 p1, float t)\n{\n    vec3 tp;\n    float tn = 1.0 - t;\n\n    tp.xyz = tn * tn * tn * p0.xyz + 3.0 * tn * tn * t * c0.xyz + 3.0 * tn * t * t * c1.xyz + t * t * t * p1.xyz;\n\n    return tp;\n}\n";
			THREE.BAS.ShaderChunk["ease_in_cubic"] = "float ease(float t, float b, float c, float d) {\n  return c*(t/=d)*t*t + b;\n}\n";
			THREE.BAS.ShaderChunk["ease_in_quad"] = "float ease(float t, float b, float c, float d) {\n  return c*(t/=d)*t + b;\n}\n";
			THREE.BAS.ShaderChunk["ease_out_cubic"] = "float ease(float t, float b, float c, float d) {\n  return c*((t=t/d - 1.0)*t*t + 1.0) + b;\n}\n";
			THREE.BAS.ShaderChunk["quaternion_rotation"] = "vec3 rotateVector(vec4 q, vec3 v)\n{\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\nvec4 quatFromAxisAngle(vec3 axis, float angle)\n{\n    float halfAngle = angle * 0.5;\n    return vec4(axis.xyz * sin(halfAngle), cos(halfAngle));\n}\n";
			THREE.BAS.PrefabBufferGeometry = function(prefab, count) {
				THREE.BufferGeometry.call(this);
				this.prefabGeometry = prefab;
				this.prefabCount = count;
				this.prefabVertexCount = prefab.vertices.length;
				this.bufferDefaults()
			};
			THREE.BAS.PrefabBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
			THREE.BAS.PrefabBufferGeometry.prototype.constructor = THREE.BAS.PrefabBufferGeometry;
			THREE.BAS.PrefabBufferGeometry.prototype.bufferDefaults = function() {
				var prefabFaceCount = this.prefabGeometry.faces.length;
				var prefabIndexCount = this.prefabGeometry.faces.length * 3;
				var prefabVertexCount = this.prefabVertexCount = this.prefabGeometry.vertices.length;
				var prefabIndices = [];
				for(var h = 0; h < prefabFaceCount; h++) {
					var face = this.prefabGeometry.faces[h];
					prefabIndices.push(face.a, face.b, face.c)
				}
				var indexBuffer = new Uint32Array(this.prefabCount * prefabIndexCount);
				var positionBuffer = new Float32Array(this.prefabCount * prefabVertexCount * 3);
				this.setIndex(new THREE.BufferAttribute(indexBuffer, 1));
				this.addAttribute('position', new THREE.BufferAttribute(positionBuffer, 3));
				for(var i = 0, offset = 0; i < this.prefabCount; i++) {
					for(var j = 0; j < prefabVertexCount; j++, offset += 3) {
						var prefabVertex = this.prefabGeometry.vertices[j];
						positionBuffer[offset] = prefabVertex.x;
						positionBuffer[offset + 1] = prefabVertex.y;
						positionBuffer[offset + 2] = prefabVertex.z
					}
					for(var k = 0; k < prefabIndexCount; k++) {
						indexBuffer[i * prefabIndexCount + k] = prefabIndices[k] + i * prefabVertexCount
					}
				}
			};
			THREE.BAS.PrefabBufferGeometry.prototype.bufferUvs = function() {
				var prefabFaceCount = this.prefabGeometry.faces.length;
				var prefabVertexCount = this.prefabVertexCount = this.prefabGeometry.vertices.length;
				var prefabUvs = [];
				for(var h = 0; h < prefabFaceCount; h++) {
					var face = this.prefabGeometry.faces[h];
					var uv = this.prefabGeometry.faceVertexUvs[0][h];
					prefabUvs[face.a] = uv[0];
					prefabUvs[face.b] = uv[1];
					prefabUvs[face.c] = uv[2]
				}
				var uvBuffer = this.createAttribute('uv', 2);
				for(var i = 0, offset = 0; i < this.prefabCount; i++) {
					for(var j = 0; j < prefabVertexCount; j++, offset += 2) {
						var prefabUv = prefabUvs[j];
						uvBuffer.array[offset] = prefabUv.x;
						uvBuffer.array[offset + 1] = prefabUv.y
					}
				}
			};
			THREE.BAS.PrefabBufferGeometry.prototype.computeVertexNormals = function() {
				var index = this.index;
				var attributes = this.attributes;
				var positions = attributes.position.array;
				if(attributes.normal === undefined) {
					this.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(positions.length), 3))
				}
				var normals = attributes.normal.array;
				var vA, vB, vC, pA = new THREE.Vector3(),
					pB = new THREE.Vector3(),
					pC = new THREE.Vector3(),
					cb = new THREE.Vector3(),
					ab = new THREE.Vector3();
				var indices = index.array;
				var prefabIndexCount = this.prefabGeometry.faces.length * 3;
				for(var i = 0; i < prefabIndexCount; i += 3) {
					vA = indices[i + 0] * 3;
					vB = indices[i + 1] * 3;
					vC = indices[i + 2] * 3;
					pA.fromArray(positions, vA);
					pB.fromArray(positions, vB);
					pC.fromArray(positions, vC);
					cb.subVectors(pC, pB);
					ab.subVectors(pA, pB);
					cb.cross(ab);
					normals[vA] += cb.x;
					normals[vA + 1] += cb.y;
					normals[vA + 2] += cb.z;
					normals[vB] += cb.x;
					normals[vB + 1] += cb.y;
					normals[vB + 2] += cb.z;
					normals[vC] += cb.x;
					normals[vC + 1] += cb.y;
					normals[vC + 2] += cb.z
				}
				for(var j = 1; j < this.prefabCount; j++) {
					for(var k = 0; k < prefabIndexCount; k++) {
						normals[j * prefabIndexCount + k] = normals[k]
					}
				}
				this.normalizeNormals();
				attributes.normal.needsUpdate = true
			};
			THREE.BAS.PrefabBufferGeometry.prototype.createAttribute = function(name, itemSize) {
				var buffer = new Float32Array(this.prefabCount * this.prefabVertexCount * itemSize);
				var attribute = new THREE.BufferAttribute(buffer, itemSize);
				this.addAttribute(name, attribute);
				return attribute
			};
			THREE.BAS.PrefabBufferGeometry.prototype.setAttribute4 = function(name, data) {
				var offset = 0;
				var array = this.geometry.attributes[name].array;
				var i, j;
				for(i = 0; i < data.length; i++) {
					var v = data[i];
					for(j = 0; j < this.prefabVertexCount; j++) {
						array[offset++] = v.x;
						array[offset++] = v.y;
						array[offset++] = v.z;
						array[offset++] = v.w
					}
				}
				this.geometry.attributes[name].needsUpdate = true
			};
			THREE.BAS.PrefabBufferGeometry.prototype.setAttribute3 = function(name, data) {
				var offset = 0;
				var array = this.geometry.attributes[name].array;
				var i, j;
				for(i = 0; i < data.length; i++) {
					var v = data[i];
					for(j = 0; j < this.prefabVertexCount; j++) {
						array[offset++] = v.x;
						array[offset++] = v.y;
						array[offset++] = v.z
					}
				}
				this.geometry.attributes[name].needsUpdate = true
			};
			THREE.BAS.PrefabBufferGeometry.prototype.setAttribute2 = function(name, data) {
				var offset = 0;
				var array = this.geometry.attributes[name].array;
				var i, j;
				for(i = 0; i < this.prefabCount; i++) {
					var v = data[i];
					for(j = 0; j < this.prefabVertexCount; j++) {
						array[offset++] = v.x;
						array[offset++] = v.y
					}
				}
				this.geometry.attributes[name].needsUpdate = true
			};
			THREE.BAS.BaseAnimationMaterial = function(parameters) {
				THREE.ShaderMaterial.call(this);
				this.shaderFunctions = [];
				this.shaderParameters = [];
				this.shaderVertexInit = [];
				this.shaderTransformNormal = [];
				this.shaderTransformPosition = [];
				this.setValues(parameters)
			};
			THREE.BAS.BaseAnimationMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
			THREE.BAS.BaseAnimationMaterial.prototype.constructor = THREE.BAS.BaseAnimationMaterial;
			THREE.BAS.BaseAnimationMaterial.prototype._0 = function() {
				return ''
			};
			THREE.BAS.BaseAnimationMaterial.prototype._1 = function() {
				return this.shaderFunctions.join('\n')
			};
			THREE.BAS.BaseAnimationMaterial.prototype._3 = function() {
				return this.shaderParameters.join('\n')
			};
			THREE.BAS.BaseAnimationMaterial.prototype._5 = function() {
				return this.shaderVertexInit.join('\n')
			};
			THREE.BAS.BaseAnimationMaterial.prototype._4 = function() {
				return this.shaderTransformNormal.join('\n')
			};
			THREE.BAS.BaseAnimationMaterial.prototype._2 = function() {
				return this.shaderTransformPosition.join('\n')
			};
			THREE.BAS.BaseAnimationMaterial.prototype.setUniformValues = function(values) {
				for(var key in values) {
					if(key in this.uniforms) {
						var uniform = this.uniforms[key];
						var value = values[key];
						switch(uniform.type) {
							case 'c':
								uniform.value.set(value);
								break;
							case 'v2':
							case 'v3':
							case 'v4':
								uniform.value.copy(value);
								break;
							case 'f':
							case 't':
								uniform.value = value
						}
					}
				}
			};
			THREE.BAS.PhongAnimationMaterial = function(parameters, uniformValues) {
				THREE.BAS.BaseAnimationMaterial.call(this, parameters);
				var phongShader = THREE.ShaderLib['phong'];
				this.uniforms = THREE.UniformsUtils.merge([phongShader.uniforms, this.uniforms]);
				this.lights = true;
				this.vertexShader = this._0();
				this.fragmentShader = phongShader.fragmentShader;
				uniformValues.map && (this.defines['USE_MAP'] = '');
				uniformValues.normalMap && (this.defines['USE_NORMALMAP'] = '');
				this.setUniformValues(uniformValues)
			};
			THREE.BAS.PhongAnimationMaterial.prototype = Object.create(THREE.BAS.BaseAnimationMaterial.prototype);
			THREE.BAS.PhongAnimationMaterial.prototype.constructor = THREE.BAS.PhongAnimationMaterial;
			THREE.BAS.PhongAnimationMaterial.prototype._0 = function() {
				return ["#define PHONG", "varying vec3 vViewPosition;", "#ifndef FLAT_SHADED", "	varying vec3 vNormal;", "#endif", THREE.ShaderChunk["common"], THREE.ShaderChunk["uv_pars_vertex"], THREE.ShaderChunk["uv2_pars_vertex"], THREE.ShaderChunk["displacementmap_pars_vertex"], THREE.ShaderChunk["envmap_pars_vertex"], THREE.ShaderChunk["lights_phong_pars_vertex"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], this._1(), this._3(), "void main() {", this._5(), THREE.ShaderChunk["uv_vertex"], THREE.ShaderChunk["uv2_vertex"], THREE.ShaderChunk["color_vertex"], THREE.ShaderChunk["beginnormal_vertex"], this._4(), THREE.ShaderChunk["morphnormal_vertex"], THREE.ShaderChunk["skinbase_vertex"], THREE.ShaderChunk["skinnormal_vertex"], THREE.ShaderChunk["defaultnormal_vertex"], "#ifndef FLAT_SHADED", "	vNormal = normalize( transformedNormal );", "#endif", THREE.ShaderChunk["begin_vertex"], this._2(), THREE.ShaderChunk["displacementmap_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["project_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], "	vViewPosition = - mvPosition.xyz;", THREE.ShaderChunk["worldpos_vertex"], THREE.ShaderChunk["envmap_vertex"], THREE.ShaderChunk["lights_phong_vertex"], THREE.ShaderChunk["shadowmap_vertex"], "}"].join("\n")
			};
		</script>

	</body>

</html>
